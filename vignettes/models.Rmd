---
title: "Use of models in SamplingStrata"
author: "Marco Ballin, Giulio Barcaroli"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: SamplingStrata.bib
vignette: >
  %\VignetteIndexEntry{Use of models in SamplingStrata}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
options(width = 999)
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)

```

# Handling Anticipated Variance

When optimizing the stratification of a sampling frame, values of the target variables Y's are supposed to be available for the generality of the units in the frame, or at least for a sample of them by means of which it is possible to estimate means and standard deviation of Y's in atomic strata. 
Of course, this assumption is seldom expected to hold.
The situation in which some proxy variables are available in the frame is much more likely to happen. In these situations, instead
of directly indicating the real target variables, proxy ones are named as Y's.
By so doing, there is no guarantee that the final stratification and allocation can ensure the compliance to the set of precision constraints.  
In order to take into account this problem, and to limit the risk of overestimating the expected precision levels of the optimized solution, it is possible to carry out the optimization by  considering, instead of the expected coefficients of variation related to proxy variables, the anticipated coefficients of variation (ACV) that depend on the model that is possile to fit on couples of real target variables and proxy ones.
In the current implementation, only models linking continuous variables can be considered. 
The definition and the use of these models is the same that has been implemented in the package *stratification* [see @baillargeon:2014]. 
In particular, the reference here is to two different models, the linear model with heteroscedasticity: 

$$Y=\beta\times X + \epsilon$$

where 

$$\epsilon \sim N(0,\sigma^{2\gamma})$$

(in case $\gamma = 0$, then the model is homoscedastic)

and the loglinear model: 

$$Y= \exp (\beta \times log(X) + \epsilon)$$

where

$$\epsilon \sim N(0,\sigma^{2})$$

In order to make evident the importance of the above, consider the following example, based on the dataset *swissmunicipalities* available in the package.


```{r, eval = T, message=F}
library(SamplingStrata)
data("swissmunicipalities")
swissmunicipalities$id <- c(1:nrow(swissmunicipalities))
swissmunicipalities$dom <- 1
```

Let us assume that in the sampling frame only variable *total population* is available for all municipalities, while *industrial area* and *buildings area* are available only on a sample of 500 municipalities.

```{r, eval = T}
set.seed(1234)
swiss_sample <- swissmunicipalities[sample(c(1:nrow(swissmunicipalities)),500),]
```

In this subset we can fit models between POPTOT and the two variables that we assume are the target of our survey.

One model for *industrial area* and *total population*:

```{r, eval = T}
mod_Airind_POPTOT <- lm(swiss_sample$Airind ~ swiss_sample$POPTOT)
summary(mod_Airind_POPTOT)
```

and one model for *buildings area* and *total population*:

```{r, eval = T}
mod_Airbat_POPTOT <- lm(swiss_sample$Airbat ~ swiss_sample$POPTOT)
summary(mod_Airbat_POPTOT)
```

We calculate the heteroscedasticity index and associated prediction standard error for both models:

```{r, eval = T}
airind <- computeGamma(mod_Airind_POPTOT$residuals,
             swiss_sample$POPTOT,
             nbins = 10)
airind
```


```{r, eval = T}
airbat <- computeGamma(mod_Airbat_POPTOT$residuals,
             swiss_sample$POPTOT,
             nbins = 10)
airbat
```


We define the *sampling frame* in this way:


```{r, eval = T}
frame <- buildFrameDF(swissmunicipalities,
                      id="id",
                      X="id",
                      Y=c("POPTOT","POPTOT"),
                      domainvalue = "dom")
```

that is, we replicate twice the variable *GDP* because it will be used once for *infant mortality* and once for *contraception*. 

We set 10% and 5% precision constraints on these variables:

```{r, eval = T}
cv <- as.data.frame(list(DOM=rep("DOM1",1),
                         CV1=rep(0.10,1),
                         CV2=rep(0.05,1),
                         domainvalue=c(1:1)
                    ))
cv
```

We now proceed in building the *strata* dataframe using the models:

```{r, eval = T}
model <- NULL
model$beta[1] <- mod_Airind_POPTOT$coefficients[2]
model$sig2[1] <- airind[2]^2
model$type[1] <- "linear"
model$gamma[1] <- airind[1]
model$beta[2] <- mod_Airbat_POPTOT$coefficients[2]
model$sig2[2] <- airbat[2]^2
model$type[2] <- "linear"
model$gamma[2] <- airbat[1] 
model <- as.data.frame(model)
model
```

```{r, eval = T}
strata <- buildStrataDF(frame, model = model, progress = FALSE)
head(strata)
```

We proceed with the optimization

```{r, eval = T}
kmean <- KmeansSolution(strata,cv,maxclusters=10,showPlot=FALSE)
nstrat <- tapply(kmean$suggestions, kmean$domainvalue,
                 FUN=function(x) length(unique(x)))
solution <- optimStrata(
    method = "atomic",
    errors = cv , 
    framesamp = frame, 
    model = model,
    iter = 50, 
    pops = 20, 
    parallel = FALSE,
    suggestions = kmean,
    nStrata = nstrat,
    showPlot = FALSE,
    writeFiles = FALSE)
```


What about the expected CV's?


```{r, eval = T}
newstrata <- updateStrata(strata,solution)
framenew <- updateFrame(frame,newstrata)
framenew <- framenew[order(framenew$ID),]
framenew$Y1 <- swissmunicipalities$Airind
framenew$Y2 <- swissmunicipalities$Airbat
results <- evalSolution(framenew, solution$aggr_strata, 200, progress = FALSE)
results$coeff_var
```

These two CV's regard respectively *industrial area* and *building area*: they are more than compliant with the precision constraints (10\% and 5\%).

# References

