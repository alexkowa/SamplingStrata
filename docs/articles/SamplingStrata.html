<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Optimization of sampling strata with the SamplingStrata package • SamplingStrata</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Optimization of sampling strata with the SamplingStrata package">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">SamplingStrata</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/SamplingStrata.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/barcaroli/SamplingStrata">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Optimization of sampling strata with the SamplingStrata package</h1>
                        <h4 class="author">Giulio Barcaroli</h4>
            
            <h4 class="date">2018-07-12</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/barcaroli/SamplingStrata/blob/master/vignettes/SamplingStrata.Rmd"><code>vignettes/SamplingStrata.Rmd</code></a></small>
      <div class="hidden name"><code>SamplingStrata.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>Let us suppose we need to design a sample survey, having a complete frame containing information on the target population (identifiers plus auxiliary information). If our sample design is a stratified one, we need to choose how to form strata in the population, in order to get the maximum advantage by the available auxiliary information. In other words, we have to decide in which way to combine the values of the auxiliary variables (from now on, the ‘X’ variables) in order to determine a new variable, called ‘stratum’. To do so, we have to take into consideration the target variables of our sample survey (from now on, the ‘Y’ variables): if, to form strata, we choose the X variables most correlated to the Y’s, the efficiency of the samples drawn by the resulting stratified frame may be greatly increased. In order to handle the whole auxiliary information in a homogenous way, we have to reduce continuous data to categorical (by mean of a k-means clustering technique, for example). Then, for every set of candidate auxiliary variables X’s, we have to decide (i) what variables to consider as active variables in strata determination, and (ii) for each active variable, what set of values (in general, what aggregation of atomic values) have to be considered. Every combination of values of each active variable determine a particular stratification of the target population, i.e. a possible solution to the problem of ‘best’ stratification. Here, by best stratification, we mean the stratification that ensures the minimum sample cost, sufficient to satisfy a set of precision constraints, set on the accuracy of the estimates of the survey target variables Y’s (constraints expressed as maximum allowable sampling variance on estimates in different domains of interest). When the cost of data collection is uniform over the strata, then the total cost is directly proportional to the overall sample size, and the convenience of a particular stratification can be measured by the associated size of the sample, whose estimates are expected to satisfy given accuracy levels. This minimum size can be determined by applying the Bethel algorithm, with its Chromy variant. In general, the number of possible alternative stratifications for a given population may be very high, depending on the number of variables and on the number of their values, and in these cases it is not possible to enumerate them in order to assess the best one. A very convenient solution to this, is the adoption of the evolutionary approach, consisting in applying a genetic algorithm that may converge towards a near-optimal solution after a finite number of iterations. The methodology is fully described in <span class="citation">M. Ballin and Barcaroli (2013)</span>, and a complete illustration of the package, together with a comparison with the <em>stratification</em> package, is in <span class="citation">Barcaroli (2014)</span>. Also a complete application in a case of network data is reported in <span class="citation">Marco Ballin and Barcaroli (2016)</span>. The implementation of the genetic algorithm is based on a modification of the functions in the <em>genalg</em> package <span class="citation">(see Willighagen 2005)</span>. In particular, the crossover operator ha been modified on the basis of the indications given by <span class="citation">O’Luing, Prestwich, and Tarim (2017)</span>.</p>
</div>
<div id="procedural-steps" class="section level1">
<h1 class="hasAnchor">
<a href="#procedural-steps" class="anchor"></a>Procedural steps</h1>
<p>The optimization of the sampling design starts by making the sampling frame available, defining the target estimates of the survey and establishing the precision constraints on them. It is then possible to determine the best stratification and the optimal allocation. Finally, we proceed with the selection of the sample. Formalizing, these are the required steps:</p>
<ul>
<li>analysis of the frame data: identification of available auxiliary information;</li>
<li>manipulation of auxiliary information: in case auxiliary variables are of the continuous type, they must be transformed into a categorical form;</li>
<li>construction of atomic strata: on the basis of the categorical auxiliary variables available in the sampling frame, a set of strata can be constructed by calculating the Cartesian product of the values of all the auxiliary variables;</li>
<li>characterization of each atomic stratum with the information related to the target variables: in order to optimise both strata and allocation of sampling units in strata, we need information on the distributions of the target variables (means and standard deviations);</li>
<li>choice of the precision constraints for each target estimate, possibly differentiated by domain;</li>
<li>optimization of stratification and determination of required sample size and allocation in order to satisfy precision constraints on target estimates;</li>
<li>analysis of the resulting optimized strata;</li>
<li>association of new labels to sampling frame units, each of them indicating the new strata resulting by the optimal aggregation of the atomic strata;</li>
<li>selection of units from the sampling frame with a  selection scheme;</li>
<li>evaluation of the found optimal solution in terms of expected precision and bias.</li>
</ul>
<p>In the following, we will illustrate each step starting from a real sampling frame, the one that comes with the R package <em>sampling</em> (the dataframe <em>swissmunicipalities</em>).</p>
<div id="analysis-of-the-frame-data-and-manipulation-of-auxiliary-information" class="section level2">
<h2 class="hasAnchor">
<a href="#analysis-of-the-frame-data-and-manipulation-of-auxiliary-information" class="anchor"></a>Analysis of the frame data and manipulation of auxiliary information</h2>
<p>As a first step, we have to define a frame dataframe containing the following information:</p>
<ul>
<li>a unique identifier of the unit (no restriction on the name, may be ‘cod’);</li>
<li>the (optional) identifier of the stratum to which the unit belongs;</li>
<li>the values of m auxiliary variables (named from X1 to Xm);</li>
<li>the (optional) values of p target variables (named from Y1 to Yp);</li>
<li>the value of the domain of interest for which we want to produce estimates (named ‘domainvalue’).</li>
</ul>
<p>By typing the following statements in the R environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SamplingStrata)
<span class="kw">require</span>(memoise)
<span class="kw">data</span>(swissmunicipalities)</code></pre></div>
<p>we get the <em>swissmunicipalities</em> dataframe, that contains 2896 observations (each observation refers to a Swiss municipality). Among the others, there are the following variables (data are referred to 2003): * REG: Swiss region. * Nom: municipality name. * Surfacesbois: wood area. * Surfacescult: area under cultivation. * Alp: mountain pasture area. * Airbat: area with buildings. * Airind: industrial area. * Pop020: number of men and women aged between 0 and 19. * Pop2040: number of men and women aged between 20 and 39. * Pop4065: number of men and women aged between 40 and 64. * Pop65P: number of men and women aged between 65 and over. * POPTOT: total population.</p>
<p>Let us suppose we want to plan a survey whose target estimates are the totals of population by age class in each Swiss region. In this case, our Y variables will be:</p>
<ul>
<li>Y1: number of men and women aged between 0 and 19.</li>
<li>Y2: number of men and women aged between 20 and 39.</li>
<li>Y3: number of men and women aged between 40 and 64.</li>
<li>Y4: number of men and women aged between 65 and over.</li>
</ul>
<p>As for the auxiliary variables (X’s), we can use all of those characterising the area use (wood, mountain or pasture, cultivated, industrial, with buildings).</p>
<p>Finally, we want to produce estimates not only for the whole country, but also for each one of the seven different regions.</p>
<p>Function <em>buildFrameDF</em> permits to organize data in a suitable mode for next processing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  id =<span class="st"> "Nom"</span>
X =<span class="st"> </span><span class="kw">c</span>(<span class="st">"POPTOT"</span>,<span class="st">"Surfacesbois"</span>,<span class="st">"Surfacescult"</span>,<span class="st">"Alp"</span>,<span class="st">"Airbat"</span>,<span class="st">"Airind"</span>)
Y =<span class="st"> </span><span class="kw">c</span>(<span class="st">"Pop020"</span>,<span class="st">"Pop2040"</span>,<span class="st">"Pop4065"</span>,<span class="st">"Pop65P"</span>)
domainvalue =<span class="st"> "REG"</span>
swissframe &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildFrameDF.html">buildFrameDF</a></span>(swissmunicipalities,id,X,Y,domainvalue)
<span class="kw">str</span>(swissframe)</code></pre></div>
<p>As the X variables are of the continuous type, first we have to reduce them in a categorical (ordinal) form.</p>
<p>A suitable way to do so, is to apply a k-means clustering method <span class="citation">(see Hartigan and Wong 1979)</span> by using the function <em>var.bin</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SamplingStrata)
swissframe$X1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(swissmunicipalities$POPTOT, <span class="dt">bins=</span><span class="dv">18</span>)
swissframe$X2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(swissmunicipalities$Surfacesbois, <span class="dt">bins=</span><span class="dv">3</span>)
swissframe$X3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(swissmunicipalities$Surfacescult, <span class="dt">bins=</span><span class="dv">3</span>)
swissframe$X4 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(swissmunicipalities$Alp, <span class="dt">bins=</span><span class="dv">3</span>)
swissframe$X5 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(swissmunicipalities$Airbat, <span class="dt">bins=</span><span class="dv">3</span>)
swissframe$X6 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(swissmunicipalities$Airind, <span class="dt">bins=</span><span class="dv">3</span>)</code></pre></div>
<p>Now, we have six different auxiliary variables of the categorical type, the first with 18 different modalities, the others with 3 modalities.</p>
<p>We write the dataframe to a tab delimited file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write.table</span> (swissframe, <span class="st">"swissframe.txt"</span>, <span class="dt">row.names=</span><span class="ot">FALSE</span>,<span class="dt">col.names=</span><span class="ot">TRUE</span>, <span class="dt">sep=</span><span class="st">"</span><span class="ch">\t</span><span class="st">"</span>, <span class="dt">quote=</span><span class="ot">FALSE</span>)</code></pre></div>
<p>In any case, this dataframe comes with the package *SamplingStrata}: it can be made available by executing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">library</span>(SamplingStrata)
<span class="kw">data</span>(swissframe)
<span class="kw">head</span>(swissframe)</code></pre></div>
</div>
<div id="construction-of-atomic-strata-and-association-of-the-information-related-to-target-variables" class="section level2">
<h2 class="hasAnchor">
<a href="#construction-of-atomic-strata-and-association-of-the-information-related-to-target-variables" class="anchor"></a>Construction of atomic strata and association of the information related to target variables</h2>
<p>The <em>strata</em> dataframe reports information regarding each stratum in the population. There is one row for each stratum. The total number of strata is given by the number of different combinations of X’s values in the frame. For each stratum, the following information is required:</p>
<ul>
<li>the identifier of the stratum (named ‘stratum’ or ‘strato’), concatenation of the values of the X variables;</li>
<li>the values of the m auxiliary variables (named from X1 to Xm) corresponding to those in the frame;</li>
<li>the total number of units in the population (named ‘N’);</li>
<li>a flag (named ‘cens’) indicating if the stratum is to be censused (=1) or sampled (=0);</li>
<li>a variable indicating the cost of interviewing per unit in the stratum (named ‘cost’);</li>
<li>for each target variable y, its mean and standard deviation, named respectively ‘Mi’ and ‘Si’);</li>
<li>the value of the domain of interest to which the stratum belongs (‘DOM1’).</li>
</ul>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(strata)
<span class="kw">head</span>(strata)</code></pre></div>
<p>If in the <em>frame</em> dataframe are also present the values of the target Y variables (from a census, or from administrative data), it is possible to automatically generate the <em>strata</em> dataframe by invoking the <em>buildStrataDF} function. Let us consider again the </em>swissframe} dataframe that we have in built in previous steps. On this frame we can apply the function *buildStrataDF}:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  swissstrata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span>(swissframe)</code></pre></div>
<p>The function takes as unique argument the name of the frame, and also writes out in the working directory the strata file, always named ‘strata.txt’. This is the structure of the created dataframe:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(swissstrata)</code></pre></div>
<p>It is worth while noting that the total number of different atomic strata is 641, lower than the dimension of the Cartesian product of the X’s (which is 4374): this is due to the fact that not all combinations of the value of the auxiliary variables are present in the sampling frame. Variables ‘cost’ and ‘cens’ are initialised respectively to 1 and 0 for all strata. It is possible to give them different values:</p>
<ul>
<li>for variable ‘cost’, it is possible to differentiate the cost of interviewing per unit by assigning real values;</li>
<li>for variable ‘cens’, it is possible to set it equal to 1 for all strata that are of the ‘take-all’ type (i.e. all units in that strata must be selected).</li>
</ul>
<p>The <em>swissstrata</em> dataframe comes together with <em>SamplingStrata</em> package, it can be made available by typing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(swissstrata)</code></pre></div>
<p>On the contrary, if there is no information in the frame regarding the target variables, it is necessary to build the strata dataframe starting from other sources, for instance a previous round of the same survey, or from other surveys. In this case, we need to read sample data by executing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">samp &lt;-<span class="st"> </span><span class="kw">read.delim</span>(<span class="st">"samplePrev.txt"</span>)</code></pre></div>
<p>The only difference is that computed mean and variances of the Y’s are sampling estimates, whose reliability should be evaluated by carefully considering their sampling variances. In addition to the naming constraints previously introduced, this case requires that a variable named ‘WEIGHT’ is present in the samp dataframe. Then we can execute this function in this way:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">strata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span>(samp)</code></pre></div>
<p>The result is much the same than in the previous case: the function creates a new dataframe, *strata}, and writes out in the working directory the strata file, named ‘strata.txt’.</p>
</div>
<div id="choice-of-the-precision-constraints-for-each-target-estimate" class="section level2">
<h2 class="hasAnchor">
<a href="#choice-of-the-precision-constraints-for-each-target-estimate" class="anchor"></a>Choice of the precision constraints for each target estimate</h2>
<p>The <em>errors</em> dataframe contains the accuracy constraints that are set on target estimates. This means to define a maximum coefficient of variation for each variable and for each domain value. Each row of this frame is related to accuracy constraints in a particular subdomain of interest, identified by the DOM1 value. In the case of the Swiss municipalities, we have chosen to define the following constraints:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(swisserrors)
swisserrors</code></pre></div>
<p>This example reports accuracy constraints on variables Y1, Y2, Y3 and Y4 that are the same for all the 7 different subdomains (Swiss regions) of domain level DOM1. Of course we can differentiate the precision constraints region by region. It is important to underline that the values of ‘domainvalue’ are the same than those in the <em>frame</em> dataframe, and correspond to the values of variable ‘DOM1’ in the strata dataframe. Once having defined dataframes containing frame data, strata information and precision constraints, it is worth while to check their internal and reciprocal coherence. It is possible to do that by using the function <em>checkInput</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/checkInput.html">checkInput</a></span>(swisserrors,swissstrata,swissframe)</code></pre></div>
<p>For instance, this function controls that the number of auxiliary variables is the same in the <em>frame</em> and in the <em>strata</em> dataframes; that the number of target variables indicated in the <em>frame</em> dataframe is the same than the number of means and standard deviations in the <em>strata</em> dataframe, and the same than the number of coefficient of variations indicated in the <em>errors</em> dataframe.</p>
<p>If we try to determine the total size of the sample required to satisfy these precision constraints, considering the current stratification of the frame (the 641 atomic strata), we can do it by simply using the function <em>bethel</em>. This function requires a slightly different specification of the constraints dataframe:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cv &lt;-<span class="st"> </span>swisserrors[<span class="dv">1</span>,]
cv</code></pre></div>
<p>because the <em>bethel</em> function does not permit to differentiate precision constraints by subdomain. In any case, the result of the application of the Bethel algorithm [see bethel:1989] is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw"><a href="../reference/bethel.html">bethel</a></span>(swissstrata,cv))</code></pre></div>
<p>That is, the required amount of units to be selected, with no optimization of sampling strata. In general, after the optimization, this number is sensibly reduced.</p>
</div>
<div id="optimization-of-frame-stratification" class="section level2">
<h2 class="hasAnchor">
<a href="#optimization-of-frame-stratification" class="anchor"></a>Optimization of frame stratification</h2>
<p>Once the strata and the constraints dataframes have been prepared, it is possible to apply the function that optimises the stratification of the frame, that is <em>optimizeStrata</em>. This function operates on all subdomains, identifying the best solution for each one of them. The fundamental parameters to be passed to optimizeStrata are:</p>
<ul>
<li>
<em>errors</em>: the (mandatory) dataframe containing the precision levels expressed in terms of maximum allowable coefficients of variation that regard the estimates on target variables of the survey</li>
<li>
<em>strata</em>: the (mandatory) dataframe containing the information related to ‘atomic’ strata, i.e. the strata obtained by the Cartesian product of all auxiliary variables X’s. Information concerns the identifiability of strata (values of X’s) and variability of Y’s (for each Y, mean and standard deviation in strata)</li>
<li>
<em>cens</em>: the (optional) dataframe containing the ‘take-all’ strata, those strata whose units must be selected in whatever sample. It has same structure than *strata} dataframe</li>
<li>
<em>strcens</em>: flag (TRUE/FALSE) to indicate if ‘take-all’ strata do exist or not. Default is FALSE</li>
<li>
<em>initialStrata</em>: This is the initial limit on the number of strata for each solution. Default is NA, and in this case it is set equal to the number of atomic strata in each domain. If the parameter <em>addStrataFactor</em> is equal to zero, then <em>initialStrata</em> is equivalent to the maximum number of strata to be obtained in the final solution.</li>
<li>
<em>addStrataFactor</em>: this parameter indicates the probability that at each mutation the number of strata may increase with respect to the current value. Default is 0.0</li>
<li>
<em>minnumstr</em>: indicates the minimum number of units that must be allocated in each stratum. Default is 2</li>
<li>
<em>iter</em>: indicates the maximum number of iterations (= generations) of the genetic algorithm. Default is 20</li>
<li>
<em>pops</em> The dimension of each generations in terms of individuals. Default is 50.</li>
<li>
<em>mut_chance</em> (mutation chance): for each new individual, the probability to change each single chromosome, i.e. one bit of the solution vector. High values of this parameter allow a deeper exploration of the solution space, but a slower convergence, while low values permit a faster convergence, but the final solution can be distant from the optimal one. Default is NA, in correspondence of which it is computed as 1/(vars+1) where vars is the length of elements in the solution.</li>
<li>
<em>elitism_rate</em>: this parameter indicates the rate of better solutions that must be preserved from one generation to another. Default is 0.2.</li>
<li>
<em>highvalue</em>: parameter for genetic algorithm. Its default value should not be changed</li>
<li>
<em>suggestions</em>: optional parameter for genetic algorithm that indicates one possible solution (maybe from previous runs) that will be introduced in the initial population. Default is NULL.</li>
<li>
<em>realAllocation</em> : if FALSE, the allocation is based on INTEGER values; if TRUE, the allocation is based on REAL values. Default is FALSE.</li>
<li>
<em>writeFiles</em> : iIndicates if the various dataframes and plots produced during the execution have to be written in the working directory. Default is FALSE.</li>
</ul>
<p>In the case of the Swiss municipalities, we can use almost all of deault values for parameters with the exception of the errors and strata dataframes, and for the option ‘writeFiles’:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">solution &lt;-<span class="st"> </span><span class="kw"><a href="../reference/optimizeStrata.html">optimizeStrata</a></span>(
    <span class="dt">errors =</span> swisserrors, 
    <span class="dt">strata =</span> swissstrata,
    <span class="dt">writeFiles =</span> <span class="ot">TRUE</span>)
<span class="kw">sum</span>(<span class="kw">ceiling</span>(solution$aggr_strata$SOLUZ))</code></pre></div>
<p>Note that by so doing the <em>initialStrata</em> parameter is set equal to the number of atomic strata in each domain . Another possibility is to set a pre-determined value for each domain, for instance equal in each domain, as c(5,5,5,5,5,5,5,5).</p>
<p>The execution of <em>optimizeStrata</em> produces the solution of 7 different optimization problems, one for each domain. We have reported in Figure 1 the convergence plot regarding the third domain.</p>
<div class="figure">
<img src="../../../../00%20Sampling/SamplingStrata%201.3/SamplingStrataGithub/vignettes/plotdom3.png" alt="Figure 1" width="100%"><p class="caption">
Figure 1
</p>
</div>
<!-- ![Figure 1](https://github.com/barcaroli/SamplingStrata/blob/master/docs/articles/plotdom3.png) -->
<p>This graph illustrates the convergence of the solution to the final one starting from the initial one (i.e. the one related to the atomic strata). Along the x-axis are reported the executed iterations, from 1 to the maximum, while on the y-axis are reported the size of the sample required to satisfy precision constraints. The upper (red) line represent the average sample size for each iteration, while the lower (black) line represents the best solution found until the i-th iteration.</p>
<p>The results of the execution are contained in the list ‘solution’, composed by two elements:</p>
<ol style="list-style-type: decimal">
<li>
<em>solution$indices</em>: the vector of the indices that indicates to what aggregated stratum each atomic stratum belongs;</li>
<li>
<em>solution$aggr_strata</em>}*: the dataframe containing information on the optimal aggregated strata.</li>
</ol>
</div>
</div>
<div id="initial-solution-with-kmeans-clustering-of-atomic-strata" class="section level1">
<h1 class="hasAnchor">
<a href="#initial-solution-with-kmeans-clustering-of-atomic-strata" class="anchor"></a>Initial solution with kmeans clustering of atomic strata</h1>
<p>In order to speed up the convergence towards the optimal solution, an initial one can be given as a “suggestion” to’optimizeStrata’ function. The function <em>KmeansSolution</em> produces this initial solution by clustering atomic strata considering the values of the means of all the target variables Y.</p>
<p>Also, the optimal number of clusters is determined inside each domain. If the default value for nstrata is used, then the number of aggregate strata is optimized by varying the number of cluster from 2 to number of atomic strata in each domain, divided by 2. Otherwise, it is possible to indicate a fixed number of aggregate strata to be obtained.</p>
<p>Other parameters are:</p>
<ul>
<li>
<em>minnumstrat</em>: the minimum number of units to allocated in each stratum(default is 2);</li>
<li>
<em>maxcluster</em>: the maximum number of clusters to be considered in the execution of kmeans algorithm;</li>
<li>
<em>showPlot</em>: if TRUE, allows to visualise the optimization.</li>
</ul>
<p>For any given number of clusters, the correspondent aggregation of atomic strata is considered as input to the function ‘bethel’. The number of clusters for which the value of the sample size necessary to fulfil precision constraints is the minimum one, is retained as the optimal one.</p>
<p>The overall solution is obtained by concatenating optimal clusters obtained in domains. The result is a dataframe with two columns: the first indicates the clusters, the second the domains:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">solutionKmeans &lt;-<span class="st"> </span><span class="kw"><a href="../reference/KmeansSolution.html">KmeansSolution</a></span>(swissstrata,
                                   swisserrors,
                                   <span class="dt">nstrata=</span><span class="ot">NA</span>,
                                   <span class="dt">minnumstrat=</span><span class="dv">2</span>,
                                   <span class="dt">maxclusters=</span><span class="ot">NA</span>,
                                   <span class="dt">showPlot=</span><span class="ot">FALSE</span>)
<span class="kw">head</span>(solutionKmeans)</code></pre></div>
<p>This solution can be given as argument to the parameter <em>suggestion</em> in the <em>optimizeStrata</em> function.</p>
<p>Suppose we want to optimize the stratification of domain 3 by making use of the initial solution given by the kmeans algorithm in that domain:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">solution_dom3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/optimizeStrata.html">optimizeStrata</a></span>(
    <span class="dt">errors =</span> swisserrors,
    <span class="dt">strata =</span> swissstrata,
    <span class="dt">alldomains =</span> <span class="ot">FALSE</span>,
    <span class="dt">dom =</span> <span class="dv">3</span>,
    <span class="dt">suggestions =</span> solutionKmeans[solutionKmeans$domainvalue ==<span class="st"> </span><span class="dv">3</span>,])
<span class="kw">sum</span>(<span class="kw">ceiling</span>(solution_dom3$aggr_strata$SOLUZ))</code></pre></div>
<p>thus obtaining a much more conventient solution than the one without the kmeans suggestion, with the same number of iterations.</p>
</div>
<div id="adjustment-of-the-final-sampling-size" class="section level1">
<h1 class="hasAnchor">
<a href="#adjustment-of-the-final-sampling-size" class="anchor"></a>Adjustment of the final sampling size</h1>
<p>After the optimization step, the final sample size is the result of the allocation of units in final strata. This allocation is such that the precision constraints are expected to be satisfied. Actually, three possible situations may occur:</p>
<ul>
<li>the resulting sample size is acceptable;</li>
<li>the resulting sample size is to high, it is not affordable with respect to the available budget;</li>
<li>the resulting sample size is too low, the available budget permits to increase the number of units.</li>
</ul>
<p>In the first case, no action is required. In the second case, it is necessary to reduce the number of units, by equally applying the same reduction rate in each stratum. In the third case, we could either to set more tight precision constraints, or proceed to increase the sample size by applying the same increase rate in each stratum. This increase/reduction process is iterative, as by applying the same rate we could find that in some strata there are not enough units to increase or to reduce. The function <em>adjustSize</em> permits to obtain the desired final sample size. Let us suppose that the obtained sample size is not affordable. We can reduce it by executing the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">adjustedStrata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/adjustSize.html">adjustSize</a></span>(<span class="dt">size=</span><span class="dv">200</span>,<span class="dt">strata=</span>solution$aggr_strata,<span class="dt">cens=</span><span class="ot">NULL</span>)
<span class="kw">sum</span>(adjustedStrata$SOLUZ)</code></pre></div>
<p>Instead, if we want to increase the size because the budget allows to do this, then this is the code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">adjustedStrata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/adjustSize.html">adjustSize</a></span>(<span class="dt">size=</span><span class="dv">400</span>,<span class="dt">strata=</span>solution$aggr_strata,<span class="dt">cens=</span><span class="ot">NULL</span>)
<span class="kw">sum</span>(adjustedStrata$SOLUZ)</code></pre></div>
<p>The difference between the desired sample size and the actual adjusted size depends on the number of strata in the optimized solution. Consider that the adjustment is performed in each stratum by taking into account the relative difference between the current sample size and the desired one: this produces an allocation that is expressed by a real number, that must be rounded. The higher the number of strata, the higher the impact of the rounding in all strata on the final adjusted sample size.</p>
</div>
<div id="analysis-of-results" class="section level1">
<h1 class="hasAnchor">
<a href="#analysis-of-results" class="anchor"></a>Analysis of results</h1>
<p>We want to analyse what kind of aggregation of the atomic strata the genetic algorithm did produce. To do so, we apply the function <em>updateStrata</em>, that assigns the labels of the new strata to the initial one in the dataframe <em>strata</em>, and produces:</p>
<ul>
<li>a new file named <em>newstrata.txt</em> containing all the information in the strata dataframe, plus the labels of the new strata;</li>
<li>a table, contained in the dataset <em>strata_aggregation.txt</em>, showing in which way the auxiliary variables X’s determine the new strata.</li>
</ul>
<p>The function is invoked in this way:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">newstrata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/updateStrata.html">updateStrata</a></span>(swissstrata, solution, <span class="dt">writeFiles =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>Now, the atomic strata are associated to the aggregate strata defined in the optimal solution, by means of the variable <em>LABEL</em>. If we want to analyse in detail the new structure of the stratification, we can look at the <em>strata_aggregation.txt</em> file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">strata_aggregation &lt;-<span class="st"> </span><span class="kw">read.delim</span>(<span class="st">"strata_aggregation.txt"</span>)
<span class="kw">head</span>(strata_aggregation)</code></pre></div>
<p>In this structure, for each aggregate stratum the values of the X’s variables in each contributing atomic stratum are reported. It is then possible to understand the meaning of each aggregate stratum produced by the optimization.</p>
</div>
<div id="updating-the-frame-and-selecting-the-sample" class="section level1">
<h1 class="hasAnchor">
<a href="#updating-the-frame-and-selecting-the-sample" class="anchor"></a>Updating the frame and selecting the sample</h1>
<p>Once the optimal stratification has been obtained, to be operational we need to accomplish the following two steps:</p>
<ul>
<li>to update the frame units with new stratum labels (combination of the new values of the auxiliary variables X’s);</li>
<li>to select the sample from the frame.</li>
</ul>
<p>As for the first, we execute the following command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">framenew &lt;-<span class="st"> </span><span class="kw"><a href="../reference/updateFrame.html">updateFrame</a></span>(swissframe, newstrata, <span class="dt">writeFiles=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>The function <em>updateFrame</em> receives as arguments the indication of the dataframe in which the frame information is memorised, and of the dataframe produced by the execution of the <em>updateStrata</em> function. The execution of this function produces a dataframe <em>framenew</em>, and also a file (named <em>framenew.txt</em>) with the labels of the new strata produced by the optimisation step. The allocation of units is contained in the <em>SOLUZ</em> column of the dataset <em>outstrata.txt</em>. At this point it is possible to select the sample from the new version of the frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sample &lt;-<span class="st"> </span><span class="kw"><a href="../reference/selectSample.html">selectSample</a></span>(framenew, solution$aggr_strata, <span class="dt">writeFiles=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>that produces two .csv files:</p>
<ul>
<li>
<em>sample.csv</em> containing the units of the frame that have been selected, together with the weight that has been calculated for each one of them;</li>
<li>
<em>sample.chk.csv</em> containing information on the selection: for each stratum, the number of units in the population, the planned sample, the number of selected units, the sum of their weights that must equalise the number of units in the population.</li>
</ul>
<p>The <em>selectSample</em> operates by drawing a simple random sampling in each stratum.</p>
<p>A variant of this function is <em>selectSampleSystematic</em>. The only difference is in the method used for selecting units in each strata, that is by executing the following steps:</p>
<ol style="list-style-type: decimal">
<li>a selection interval is determined by considering the inverse of the sampling rate in the stratum;</li>
<li>a starting point is determined by selecting a value in this interval;</li>
<li>the selection proceeds by selecting as first unit the one corresponding the above value, and then selecting all the units individuated by adding the selection interval.</li>
</ol>
<p>This selection method can be useful if associated to a particular ordering of the selection frame, where the ordering variable(s) can be considered as additional stratum variable(s). For instance, we could decide that it could be important to consider the overall population in municipalities when selecting units. Here is the code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># adding POPTOT to framenew</span>
<span class="kw">data</span>(<span class="st">"swissmunicipalities"</span>)
framenew &lt;-<span class="st"> </span><span class="kw">merge</span>(framenew,swissmunicipalities[,<span class="kw">c</span>(<span class="st">"REG"</span>,<span class="st">"Nom"</span>,<span class="st">"POPTOT"</span>)],
                  <span class="dt">by.x=</span><span class="kw">c</span>(<span class="st">"REG"</span>,<span class="st">"ID"</span>),<span class="dt">by.y=</span><span class="kw">c</span>(<span class="st">"REG"</span>,<span class="st">"Nom"</span>))
<span class="co"># selection of sample with systematic method</span>
sample &lt;-<span class="st"> </span><span class="kw"><a href="../reference/selectSampleSystematic.html">selectSampleSystematic</a></span>(<span class="dt">frame=</span>framenew,
                                 <span class="dt">outstrata=</span>solution$aggr_strata,
                                 <span class="dt">sortvariable =</span> <span class="kw">c</span>(<span class="st">"POPTOT"</span>))
<span class="kw">head</span>(sample)</code></pre></div>
</div>
<div id="evaluation-of-the-found-solution" class="section level1">
<h1 class="hasAnchor">
<a href="#evaluation-of-the-found-solution" class="anchor"></a>Evaluation of the found solution</h1>
<p>In order to be confident about the quality of the found solution, the function <em>evalSolution</em> allows to run a simulation, based on the selection of a desired number of samples from the frame to which the stratification, identified as the best, has been applied. The user can invoke this function also indicating the number of samples to be drawn:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eval &lt;-<span class="st"> </span><span class="kw"><a href="../reference/evalSolution.html">evalSolution</a></span>(framenew, solution$aggr_strata, <span class="dt">nsampl=</span><span class="dv">50</span>, <span class="dt">writeFiles=</span><span class="ot">TRUE</span>) </code></pre></div>
<p>For each drawn sample, the estimates related to the Y’s are calculated. Their mean and standard deviation are also computed, in order to produce the CV related to each variable in every domain. These CV’s are written to an external csv file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">expected_cv &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">"simulation//expected_cv.csv"</span>)
expected_cv</code></pre></div>
<p>These values are on average compliant with the precision constraints set (see Figure 2).</p>
<div class="figure">
<img src="../../../../00%20Sampling/SamplingStrata%201.3/SamplingStrataGithub/vignettes/cv.png" alt="Figure 2" width="80%"><p class="caption">
Figure 2
</p>
</div>
<!-- ![Figure 2](cv.png) -->
</div>
<div id="handling-take-all-strata-in-the-optimization-step" class="section level1">
<h1 class="hasAnchor">
<a href="#handling-take-all-strata-in-the-optimization-step" class="anchor"></a>Handling ‘take-all’ strata in the optimization step</h1>
<p>As input to the optimization step, together with proper sampling strata, it is also possible to provide <em>take-all</em> strata. These strata will not be subject to optimisation as the proper strata, but they will contribute to the determination of the best stratification, as their presence in a given domain will permit to satisfy precision constraint with a lower number of units belonging to sampling strata.</p>
<p>In order to correctly execute the optimizaton and further steps, it is necessary to perform a pre-processing of the overall input. The first step to be executed consists in the bi-partition of units to be censused and of units to be sampled, in order to build two different frames:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(swisserrors)
<span class="kw">data</span>(swissstrata)
<span class="kw">data</span>(swissframe)
<span class="co">#----Selection of units to be censused from the frame</span>
framecens &lt;-<span class="st"> </span>swissframe[ (swissframe$domainvalue ==<span class="st"> </span><span class="dv">1</span> |
<span class="st">                          </span>swissframe$domainvalue ==<span class="st"> </span><span class="dv">4</span>) &amp;<span class="st"> </span>
<span class="st">                         </span>(swissframe$X2 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                          </span>swissframe$X3 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                          </span>swissframe$X4 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                          </span>swissframe$X5 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                          </span>swissframe$X6 ==<span class="st"> </span><span class="dv">1</span>)  , ]
<span class="co">#----Selection of units to be sampled from the frame</span>
<span class="co"># (complement to the previous)</span>
framesamp &lt;-<span class="st"> </span>swissframe[!((swissframe$domainvalue ==<span class="st"> </span><span class="dv">1</span> |
<span class="st">                           </span>swissframe$domainvalue ==<span class="st"> </span><span class="dv">4</span>) &amp;<span class="st"> </span>
<span class="st">                          </span>(swissframe$X2 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                           </span>swissframe$X3 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                           </span>swissframe$X4 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                           </span>swissframe$X5 ==<span class="st"> </span><span class="dv">1</span> &amp;
<span class="st">                           </span>swissframe$X6 ==<span class="st"> </span><span class="dv">1</span>)) , ]</code></pre></div>
<p>In this way, we have included all units belonging to ‘take-all’ strata in ‘framecens’, and the remaining in ‘framesamp’. At the end of the process, the sample will be selected from ‘framesamp’, while the units in ‘framecens’ will be simply added to the sample.</p>
<p>We can obtain census strata and sampling strata by applying <em>buildStrataDF</em> respectively to to <em>framecens</em> and <em>framesamp</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Build strata to be censused and sampled</span>
cens &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span>(framecens)
<span class="kw">sum</span>(cens$N)
strata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span>(framesamp)
<span class="kw">sum</span>(strata$N)</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(cens$N)
<span class="kw">sum</span>(strata$N)</code></pre></div>
<p>Now we have all required inputs to run ‘optimizeStrata’ in presence of ‘take-all’ stata:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">solution &lt;-<span class="st"> </span><span class="kw"><a href="../reference/optimizeStrata.html">optimizeStrata</a></span>(
    <span class="dt">errors =</span> swisserrors, 
    <span class="dt">strata =</span> strata, 
    <span class="dt">cens =</span> cens, 
    <span class="dt">strcens =</span> <span class="ot">TRUE</span> 
)</code></pre></div>
<p>Once the optimized solution has been produced, the next steps are executed by considering only the sampling part of the frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">newstrata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/updateStrata.html">updateStrata</a></span>(strata, solution)
<span class="co"># updating sampling frame with new strata labels</span>
framenew &lt;-<span class="st"> </span><span class="kw"><a href="../reference/updateFrame.html">updateFrame</a></span>(<span class="dt">frame=</span>framesamp,<span class="dt">newstrata=</span>newstrata)
<span class="co"># selection of sample from sampling strata</span>
sample &lt;-<span class="st"> </span><span class="kw"><a href="../reference/selectSample.html">selectSample</a></span>(<span class="dt">frame=</span>framenew,<span class="dt">outstrata=</span>solution$aggr_strata)</code></pre></div>
<p>Finally, the units in the ‘take-all’ strata can be added to sampled ones. First, the census frame needs to be made homogeneous to the sample frame in order to permit the ‘rbind’ step:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># addition of necessary variables to </span>
<span class="kw">colnames</span>(framesamp) &lt;-<span class="st"> </span><span class="kw">toupper</span>(<span class="kw">colnames</span>(framesamp))
<span class="kw">colnames</span>(framecens) &lt;-<span class="st"> </span><span class="kw">toupper</span>(<span class="kw">colnames</span>(framecens))
framecens$WEIGHTS &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>,<span class="kw">nrow</span>(framecens))
framecens$FPC &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>,<span class="kw">nrow</span>(framecens))
framecens$LABEL &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"999999"</span>,<span class="kw">nrow</span>(framecens))
framecens$STRATUM &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"999999"</span>,<span class="kw">nrow</span>(framecens))
framecens$STRATO &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"999999"</span>,<span class="kw">nrow</span>(framecens))</code></pre></div>
<p>The overall set of units to be surveyed is obtainable in this way:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">survey &lt;-<span class="st"> </span><span class="kw">rbind</span>(sample,framecens)</code></pre></div>
<p>and this is the proportion of sampling and censused units:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">survey$cens &lt;-<span class="st"> </span><span class="kw">ifelse</span>(survey$LABEL ==<span class="st"> "999999"</span>,<span class="dv">1</span>,<span class="dv">0</span>)
<span class="kw">table</span>(survey$cens)</code></pre></div>
</div>
<div id="handling-anticipated-variance" class="section level1">
<h1 class="hasAnchor">
<a href="#handling-anticipated-variance" class="anchor"></a>Handling Anticipated Variance</h1>
<p>In the previous sections it has been assumed that, when optimizing the stratification of a sampling frame, values of the target variables Y’s are available for the generality of the units in the frame, or at least for a sample of them bay means of which it is possible to estimate means and standard deviation of Y’s in atomic strata. Of course, this assumption is seldom expected to hold. The situation in which some proxy variables are available in the frame is much more likely to happen. In these situations, instead of directly indicating the real target variables, proxy ones are named as Y’s. By so doing, there is no guarantee that the final stratification and allocation can ensure the compliance to the set of precision constraints.<br>
In order to take into account this problem, and to limit the risk of overestimating the expected precision leveles of the optimized solution, it is possible to carry out the optimization by considering, instead of the expected coefficients of variation related to proxy variables, the anticipated coefficients of variation (ACV) that depend on the model that is possile to fit on couples of real target variables and proxy ones. In the current implementation, only linear models linking continuous variables can be considered. The definition and the use of these models is the same that has been implemented in <span class="citation">Baillargeon and Rivest (2014)</span>. In particular, the reference here is to the heteroscedastic linear model:</p>
<p><span class="math inline">\(Y=betaX + epsilon\)</span></p>
<p>where</p>
<p><span class="math inline">\(epsilon = \sim N(0,sig2 X^{gamma})\)</span></p>
<p>In case gamma = 0, then the model is homoscedastic.</p>
<p>In order to make evident the importance of the above, consider the following example.</p>
<p>Let the <em>iris</em> dataset be the sampling frame. Suppose that the target variable is Petal.Lenght, but in the frame we only have Petal.Width. So we declare this latter variable as the Y.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(iris)
iris$id &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(iris))
iris$dom &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>,<span class="kw">nrow</span>(iris))
iris$X1 &lt;-<span class="st"> </span><span class="kw">ifelse</span>(iris$Species ==<span class="st"> "setosa"</span>,<span class="dv">1</span>,iris$Species)
iris$X1 &lt;-<span class="st"> </span><span class="kw">ifelse</span>(iris$Species ==<span class="st"> "versicolor"</span>,<span class="dv">2</span>,iris$Species)
iris$X1 &lt;-<span class="st"> </span><span class="kw">ifelse</span>(iris$Species ==<span class="st"> "virginica"</span>,<span class="dv">3</span>,iris$Species)
nbins =<span class="st"> </span><span class="dv">6</span>
<span class="kw">set.seed</span>(<span class="dv">1234</span>)
iris$X2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(iris$Sepal.Width,nbins)
iris$X3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/var.bin.html">var.bin</a></span>(iris$Sepal.Length,nbins)
frame &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildFrameDF.html">buildFrameDF</a></span>(iris,
<span class="dt">id=</span><span class="st">"id"</span>,
<span class="dt">X=</span><span class="kw">c</span>(<span class="st">"X1"</span>,<span class="st">"X2"</span>,<span class="st">"X3"</span>),
<span class="dt">Y=</span><span class="kw">c</span>(<span class="st">"Petal.Width"</span>),
<span class="dt">domainvalue =</span> <span class="st">"dom"</span>)
strata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span>(frame, <span class="dt">model =</span> <span class="ot">NULL</span>)
errors &lt;-<span class="st"> </span><span class="ot">NULL</span>
errors$DOM &lt;-<span class="st"> "DOM1"</span>
errors$cv1 &lt;-<span class="st"> </span><span class="fl">0.05</span>
errors$domainvalue &lt;-<span class="st"> </span><span class="dv">1</span>
errors &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(errors)</code></pre></div>
<p>We can optimize the stratification with regard to Petal.Width:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1234</span>)
solution &lt;-<span class="st"> </span><span class="kw"><a href="../reference/optimizeStrata.html">optimizeStrata</a></span>(
errors , 
strata , 
<span class="dt">iter =</span> <span class="dv">50</span>,
<span class="dt">pops =</span> <span class="dv">40</span>
)
<span class="kw">sum</span>(<span class="kw">ceiling</span>(solution$aggr_strata$SOLUZ))</code></pre></div>
<p>and we obtain a solution with a sample size equal to 11. In order to take into account the fact that Petal.Width is a proxy of Petal.Length and not the real target variable, we define the following parameters for the linear model linking the two variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> </span><span class="ot">NULL</span>
model$beta.lin[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(iris$Petal.Length/iris$Petal.Width)
model$sig2.lin[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">var</span>(iris$Petal.Length/iris$Petal.Width)
model$gamma[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">1</span>
model$type &lt;-<span class="st"> "linear"</span>
model &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(model)
model</code></pre></div>
<p>Now, the optimization step takes into account this model and produces the following result:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1234</span>)
strata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span>(frame, <span class="dt">model =</span> model)
solution &lt;-<span class="st"> </span><span class="kw"><a href="../reference/optimizeStrata.html">optimizeStrata</a></span>(
errors , 
strata , 
<span class="dt">iter =</span> <span class="dv">50</span>,
<span class="dt">pops =</span> <span class="dv">40</span>
)</code></pre></div>
<p>thus obtaining a solution with a sample size much higher:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">ceiling</span>(solution$aggr_strata$SOLUZ))</code></pre></div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-baillargeon:2014">
<p>Baillargeon, Sophie, and Louis-Paul Rivest. 2014. <em>Stratification: Univariate Stratification of Survey Populations</em>. <a href="https://CRAN.R-project.org/package=stratification" class="uri">https://CRAN.R-project.org/package=stratification</a>.</p>
</div>
<div id="ref-ballin:2013">
<p>Ballin, M., and G. Barcaroli. 2013. “Joint Determination of Optimal Stratification and Sample Allocation Using Genetic Algorithm.” <em>Survey Methodology</em> 39: 369–93.</p>
</div>
<div id="ref-ballin:2016">
<p>Ballin, Marco, and Giulio Barcaroli. 2016. “Optimization of Stratified Sampling with the R Package SamplingStrata: Applications to Network Data.” <em>Computational Network Analysis with R: Applications in Biology, Medicine and Chemistry</em>. John Wiley &amp; Sons.</p>
</div>
<div id="ref-barcarol:2013">
<p>Barcaroli, G. 2014. “SamplingStrata: An R Package for the Optimization of Stratified Sampling.” <em>Journal of Statistical Software</em> 61 (4): 1–24. <a href="http://www.jstatsoft.org/v61/i04/" class="uri">http://www.jstatsoft.org/v61/i04/</a>.</p>
</div>
<div id="ref-hartigan:1979">
<p>Hartigan, J. A., and M. A. Wong. 1979. “A K-Means Clustering Algorithm.” <em>Applied Statistics</em> 28: 100–108.</p>
</div>
<div id="ref-oluing:2017">
<p>O’Luing, M., S. Prestwich, and S. Armagan Tarim. 2017. “Constructing Strata to Solve Sample Allocation Problems by Grouping Genetic Algorithm.” <em>ArXiv:1709.03076</em>.</p>
</div>
<div id="ref-willighagen:2005">
<p>Willighagen, E. 2005. <em>Genalg: R Based Genetic Algorithm</em>. <a href="http://CRAN.R-project.org/package=genalg" class="uri">http://CRAN.R-project.org/package=genalg</a>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li>
<a href="#procedural-steps">Procedural steps</a><ul class="nav nav-pills nav-stacked">
<li><a href="#analysis-of-the-frame-data-and-manipulation-of-auxiliary-information">Analysis of the frame data and manipulation of auxiliary information</a></li>
      <li><a href="#construction-of-atomic-strata-and-association-of-the-information-related-to-target-variables">Construction of atomic strata and association of the information related to target variables</a></li>
      <li><a href="#choice-of-the-precision-constraints-for-each-target-estimate">Choice of the precision constraints for each target estimate</a></li>
      <li><a href="#optimization-of-frame-stratification">Optimization of frame stratification</a></li>
      </ul>
</li>
      <li><a href="#initial-solution-with-kmeans-clustering-of-atomic-strata">Initial solution with kmeans clustering of atomic strata</a></li>
      <li><a href="#adjustment-of-the-final-sampling-size">Adjustment of the final sampling size</a></li>
      <li><a href="#analysis-of-results">Analysis of results</a></li>
      <li><a href="#updating-the-frame-and-selecting-the-sample">Updating the frame and selecting the sample</a></li>
      <li><a href="#evaluation-of-the-found-solution">Evaluation of the found solution</a></li>
      <li><a href="#handling-take-all-strata-in-the-optimization-step">Handling ‘take-all’ strata in the optimization step</a></li>
      <li><a href="#handling-anticipated-variance">Handling Anticipated Variance</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Giulio Barcaroli.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
